
async function wsPing(url, runs=8){
  return new Promise((resolve,reject)=>{
    const ws=new WebSocket(url);
    const times=[]; let sent=0;
    ws.onopen=()=>{ const sendOne=()=>{ const client_ts=Date.now(); ws.send(JSON.stringify({type:'ping', client_ts})); sent++; if(sent<runs) setTimeout(sendOne,120); }; sendOne(); };
    ws.onmessage=(ev)=>{ try{ const d=JSON.parse(ev.data); if(d.type==='pong'){ const now=Date.now(); const rtt = now - (d.client_ts||now); times.push(rtt); } }catch(e){} if(times.length>=runs){ ws.close(); times.sort((a,b)=>a-b); resolve(times[Math.floor(times.length/2)]);} };
    ws.onerror=(e)=>reject(e);
    setTimeout(()=>{ if(times.length===0) reject(new Error('WS timeout')) },5000);
  });
}
function createChart(){ const ctx=document.getElementById('chart').getContext('2d'); return new Chart(ctx,{type:'line',data:{labels:[],datasets:[{label:'Mbps',data:[],fill:false,tension:0.2,pointRadius:0}]},options:{responsive:true,scales:{x:{display:true},y:{display:true,suggestedMin:0}}}}); }
async function downloadStream(url){ const resp=await fetch(url); if(!resp.ok) throw new Error('download failed'); const reader=resp.body.getReader(); let received=0; const start=performance.now(); while(true){ const {done,value}=await reader.read(); if(done) break; received += value.length; const now=performance.now(); const secs=(now-start)/1000; const mbps=(received*8)/(secs*1_000_000); if(window.onProgress) window.onProgress(mbps); } const end=performance.now(); return {(received*8)/((end-start)/1000)/1_000_000, bytes:received}; }
async function parallelDownload(streams, chunkMB){ const size=chunkMB*1024*1024; const tasks=[]; for(let i=0;i<streams;i++) tasks.push(downloadStream('/download/chunk/?size='+size)); return Promise.all(tasks); }
async function uploadTest(sizeBytes){ const chunk=new Uint8Array(1024*1024); for(let i=0;i<chunk.length;i++) chunk[i]=i&0xff; const parts=[]; let remaining=sizeBytes; while(remaining>0){ parts.push(chunk.slice(0,Math.min(chunk.length,remaining))); remaining -= chunk.length; } const blob=new Blob(parts); const start=performance.now(); const r=await fetch('/upload/chunk/?_='+Math.random(), {method:'POST', body:blob}); const end=performance.now(); if(!r.ok) throw new Error('upload failed'); const secs=(end-start)/1000; return (sizeBytes*8)/(secs*1_000_000); }
const chart=createChart(); document.getElementById('run').addEventListener('click', async ()=>{ const pingEl=document.getElementById('ping'); const dlEl=document.getElementById('download'); const ulEl=document.getElementById('upload'); const streams=parseInt(document.getElementById('streams').value||'4'); const chunkmb=parseInt(document.getElementById('chunkmb').value||'5'); pingEl.textContent='…'; dlEl.textContent='…'; ulEl.textContent='…'; window.onProgress=(mbps)=>{ chart.data.labels.push(new Date().toLocaleTimeString()); chart.data.datasets[0].data.push(+mbps.toFixed(2)); if(chart.data.labels.length>100){ chart.data.labels.shift(); chart.data.datasets[0].data.shift(); } chart.update('none'); }; try{ const wsProto=location.protocol==='https:'?'wss':'ws'; const wsUrl=wsProto+'://'+location.host+'/ws/ping/'; const ping=await wsPing(wsUrl,8); pingEl.textContent=ping+' ms'; const results=await parallelDownload(streams,chunkmb); const totalMbps=results.reduce((s,r)=>s + (r.mbps||0),0); dlEl.textContent=totalMbps.toFixed(2); const up=await uploadTest(5*1024*1024); ulEl.textContent=up.toFixed(2); }catch(e){ console.error(e); } finally{ window.onProgress=null; } });
